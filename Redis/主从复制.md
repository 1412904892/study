- [主从复制](#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6)
  - [主从复制的作用](#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8)
  - [主从复制的实现原理](#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
    - [连接建立阶段](#%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E9%98%B6%E6%AE%B5)
      - [保存主节点信息](#%E4%BF%9D%E5%AD%98%E4%B8%BB%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF)
      - [建立socket连接](#%E5%BB%BA%E7%AB%8Bsocket%E8%BF%9E%E6%8E%A5)
      - [发送ping命令](#%E5%8F%91%E9%80%81ping%E5%91%BD%E4%BB%A4)
      - [身份验证](#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81)
      - [发送从节点端口信息](#%E5%8F%91%E9%80%81%E4%BB%8E%E8%8A%82%E7%82%B9%E7%AB%AF%E5%8F%A3%E4%BF%A1%E6%81%AF)
    - [数据同步阶段](#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%98%B6%E6%AE%B5)
    - [命令传播阶段](#%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E9%98%B6%E6%AE%B5)
  - [数据同步阶段【全量复制和部分复制】](#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%98%B6%E6%AE%B5%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%E5%92%8C%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6)
    - [全量复制](#%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6)
    - [部分复制](#%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6)
  - [psync命令的执行过程](#psync%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B)

# 主从复制
## 主从复制的作用
1）数据冗余：主从复制实现了数据热备份，是持久化之外的另外一种数据冗余方式

2）故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复，实际上是一种服务的冗余

3）负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），以此来分担服务器的负载，尤其在写少读多的场景下，可以大大提高Redis的并发量

4）高可用基石：主从复制是哨兵和集群能够实施的基础
## 主从复制的实现原理
### 连接建立阶段
#### 保存主节点信息
从节点服务器内部维护了两个字段，masterhost和masterport字段，用于存储主节点的ip和端口信息
需要注意的是，slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。
#### 建立socket连接
从节点每秒调用复制定时函数，如果发现有主节点可以连接，便会根据主节点的ip和port，创建socket连接。如果创建成功，则：
从节点：为该socket建立一个专门处理复制工作的文件时间处理器，负责后续的复制工作
主节点：接收到从节点的sockt连接后，为该socket创建相应的客户端状态，并将从节点看作是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送请求命令的形式进行。
#### 发送ping命令
从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是检查socket是否可用，以及主节点能否处理请求。
发送ping命令后，会出现三种情况：
1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续
2）超时：一定时间后从节点仍未收到主节点的恢复信息，说明socket连接不可用，则从节点断开socket连接并且重连
3）返回pong以外的结果：从节点断开socket连接，并且重连
#### 身份验证
如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。
如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。
#### 发送从节点端口信息
身份验证之后，从节点会向主节点发送其监听的端口号（前述例子中为6380），主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。
### 数据同步阶段
主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步。
### 命令传播阶段
数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。
需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。
repl-disable-tcp-nodelay no：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。
## 数据同步阶段【全量复制和部分复制】
- 全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。
- 部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。
### 全量复制
Redis通过psync命令进行全量复制的过程：
1）从节点判断无法进行部分复制，向主节点发送全量复制的请求，或者从节点发送部分复制的请求，但是主节点判断无法进行部分复制。  

2）主节点在接收到全量复制的请求后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区来缓存从现在开始执行的写命令。

3）主节点执行完bgsave之后，将得到的RDB文件发送给从节点，从节点首先清楚自己的旧数据，然后载入rdb文件，将数据库更新到主节点执行BGSAVE时的状态。

4）主节点将之前缓冲区中的所有写命令按顺序发送给从节点，从节点执行这些写命令，将数据库更新到和主节点一致的状态

5）如果从节点开启了AOF，那么会触发bgrewriteaof，从而保证AOF文件也更新到最新的状态。

### 部分复制
1）复制偏移量  
主节点和从节点会分别维护一个复制偏移量offset，代表的是主节点向从节点传递的字节数。主节点每次向从节点发送N个字节的数据，那么主节点的offset就加N，从节点每接受N分字节的数据，那么从节点的offset也相应的加N。offset用于判断主从节点的数据库是否一致，如果两者的offset相同，那么数据一致，如果不同则不一致。此时可以通过两者的offset找出从节点所缺少的那部分数据。

2）复制积压缓冲区  
复制积压缓冲区由主节点维护、固定长度、先进先出的队列，默认大小为1MB，当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据，，无论有几个 从节点，该缓冲区的数量只有一个。  
在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份，除了存储写命令，复制积压缓冲区中还存储了其中每个字节对应的offset偏移量，由于该缓冲区是定长而且是先进先出的，那么时间较早的写命令会被挤出缓冲区。  
当主从节点的offset的差距超过缓冲区的大小，将无法执行部分复制，只能执行全量复制。

从节点将offset发送给主节点之后，主节点根据offset和复制积压缓冲区判断是否决定进行部分复制：  
- 如果offset偏移量之后的数据仍在缓冲区中，执行部分复制
- 如果offset偏移量之后的数据不再缓冲区中，那么执行全量复制

3）服务器运行ID  
每个Redis节点在启动时都会有一个runid，主从节点初次复制时，主节点会将自己的runid发送给从节点，当断线重连时，从节点会将这个runid发送给主节点，主节点根据runid判断能够进行部分复制。
- 如果从节点保存的runid和主节点的现在的runid相同，说明之前该主从节点之间同步过，主节点会继续尝试是否可以进行部分复制（根据offset和复制积压缓冲区来判断）
- 如果从节点保存的runid和现在主节点的runid不同，说明从节点在断线之前同步的Redis节点不是当前的节点，只能进行全量复制。

## psync命令的执行过程
1. 首先，从节点根据当前的状态，决定如何调用psync命令：
   - 如果从节点之前从未执行slaveof或者执行过slaveof no one，则从节点向主节点请求进行全量复制
   - 如果从节点之前执行过slaveof，则发送命令为psync runid offset,其中runid是上次主从复制的runid,offset是上次主从复制的偏移量
2. 主节点接受到psync命令后，根据当前服务器状态决定执行全量复制，还是部分复制  
   - 如果主节点和从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中存在，那么执行部分复制
   - 如果主节点和从节点的runid不同，或者从节点发送的offset之后的数据已经不在复制挤压缓冲区中，那么执行全量复制。


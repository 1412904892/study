##1. TCP/IP协议
- <font face="黑体" color="Gree">三次握手</font>  
（1） 序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送事进行标记。  
（2） 确认号：ack序号，占32位，只有ACK标志位为1时，确认序号才有效，ack=seq+1  
（3） ACK：确认序号有效  
（4） SYN：发起一个新的连接  
（5） FIN：释放一个连接  
值得注意的是，ack和ACK并不是同一种含义；
<center>
￼
</center>
（1） 第一次握手，Client端将标志位SYN置为1表示发起一个新的连接，随机产生一个序列号x作为自己的初始序列号seq发送给Server，Client进入SYN_SENT状态; 

（2） 第二次握手：Server接受到数据包后由标志位SYN=1知道Client请求建立一个连接，Server将标识位SYN和ACK都置为1，ack=x+1,表示准备接受序列号为x+1的包，同时告诉Client自己的序列号seq=y. Server进入SYN_RCVD状态。  
（3） 第三次握手：Client告诉Server收到了Server的确认消息并准备建立连接，Client自己此条消息的序列号是x+1，所以seq=x+1，而ack=y+1是表示Client正准备接收Server序列号为y+1的数据包。

****************************************************************  
<font face="黑体" color="red">&ensp;&ensp;&ensp;为什么需要三次握手，而不是两次？</font>  
为了防止已经失效的连接请求报文段突然又发送到B，因而产生错误。
1. 正常情况下。A发出连接请求，但因为连接请求报文丢失而没有收到确认，于是A重传一次连接请求，后来收到确认，建立连接。数据传输完毕后，就释放连接。A一共发送连个连接请求，一个丢失，一个到达B。此时不存在“已失效的请求报文段”。  

2. 异常情况。A第一发送的请求没有丢失，而是因为网络阻塞以致延迟到连接释放后才到达B。本来这是一个已经失效的报文，但B接收到这此失效请求报文段后，就误认为是A又发出了一次新的连接请求，于是向A发出确认报文段，同意建立连接。假如不采用三次握手，B在发出确认报文后，新的连接就已经建立。但是现在A没有发出建立连接的请求，所以不会理睬B的确认，也不会向B发送数据。但B却认为新的连接已经建立，一直等待A发送数据，白白浪费了B的资源。  
如果采用三次握手可以有效的方式上述的事件发生。例如在刚才的情况下，A不会向B的确认发出确认，B由于收不到确认，就知道A没有要求建立连接。  
-  <font face="黑体" color="Red">四次挥手</font>  
由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。

1. A的应用进程向B发出释放连接报文段，并停止发送数据，主动关闭TCP连接。A把释放连接报文段首部的FIN置为1，其序列号seq=u，u等于前面已传送过的数据的最后一个字节的序号+1。这时A进入FIN-WAIT-1状态，等待B的确认。<font color="red">TCP 规定FIN报文段即使不携带数据也要消耗一个序号。</font>    
   
2. B在收到A的释放连接报文段后即发出确认，确认号为ack=u+1，,而这个报文段自己的序号是v，v于B前面已经发送过的数据的最后一个字节的序号加1.然后B就进入CLOSE_WAIT状态。TCP进程服务器这时通知高层应用进程，因而从A到B的这个方向的连接就释放了，这时TCP连接处于半关闭(half_close)状态。即A已经没有数据要发送了，但B如有数据发送A仍可以接受。  
     
3. A收到来自B的确认后，进入FIN-WAIT-2状态，等待B发出连接释放报文段。  
4. 若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文FIN=1.现在假定序号为w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已经发送的确认号ack=u+1。这时B就进入LAST-ACK状态。  
5. A在收到B的释放报文段后，发出确认。在确认报文段把ACK设置为1，确认号ack=w+1，而自己的序列号seq=u+1。然后进入TIME-WAIT状态。请注意现在连接还没有释放。必须经过时间等待计时器设置的时间2MSL后，A进入CLOSED状态。MSL（最长报文段寿命）。 
   
***
     
- CLOSED: 这个没什么好说的了，表示初始状态。  
- LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。  
- SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。  
- SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。  
- ESTABLISHED：这个容易理解了，表示连接已经建立了。  
- FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。
- FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。
- TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。
- CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什 么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。
- CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在- - CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。
- LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。  

*****************************************  
<font color="red">为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</font>  
　　这是因为：虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状 态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于 LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的 ACK报文。
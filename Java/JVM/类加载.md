## 类加载过程
![load](image/Load.png)
从上图可以看见一共分为三个步骤  
1. 加载  
   程序运行之前JVM会把编译完成的.class二进制文件加载到内存中，
2. 连接
   验证：确保类加载的正确性，
   准备：为类的静态变量分配内存，并为其设置一个初始值，被final修饰的静态变量，会直接赋予原值
   解析：将常量池中的符号引用转换为直接引用
3. 初始化
   将类中所有被staic关键字标识的代码统一执行一遍，如果执行的是静态变量，那么使用用户指定的值覆盖之前准备阶段设置的初始值；如果执行的是static代码块，那么在初始化阶段，JVM就会执行static代码块中定义的所有操作。  

## 双亲委派模型  
### 类加载器的种类  
Bootstrap ClassLoader,Extension ClassLoader,Application ClassLoader

### 双亲委派模型的过程  
某个特定的类加载器在接收到类加载的请求后，首先将加载任务委托给父类加载，依次递归，如果父类加载器可以完成类的加载任务，就成功返回，如果父类加载不了，才自己去加载。  

使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。

## JVM的分代回收机制   
JVM将堆分为年轻代和老年代，年轻代有分为三个区：Eden、survivorFrom、survivorTo。survivorFrom和survivorTo是相对的，不是固定不变的。

1. 绝大多数刚创建的对象都会被分配在Eden区，其中大多数对象很快就会消亡。Eden区是一个连续的内存空间，所以在其上分配内存的速度很快；
   
2. 当Eden内存空间被占满，则会执行一次minor GC，将Eden和survivorFrom中消亡的对象清除掉，并将存活的对象复制到survivorTo中。如果survivorFrom中有的对象的年龄超过15（虚拟机默认是15），则将该对象复制到老年代；

3. 随着不断有对象晋升到老年代，当老年代的内存空间不足时，就会触发Full GC。这时会将年轻代和老年代中大部分垃圾对象清除掉。

## 垃圾回收算法
1. 标记-清除算法
   对于那些消亡的对象做上标记，然后清除。但是这样会造成内存碎片，所以如果下次有一个较大的对象需要分配内存时，可能内存仍然不够，这时不得不在触发一次垃圾回收。

2. 复制算法(Java新生代的垃圾回收算法)
   首先还是先标记处需要回收的内存，对于那些不需要回收的内存，将其复制到新的内存区域，这样旧的内存区域可以全部回收。

3. 标记-压缩算法(Java老年代的垃圾回收算法)
   对于新生代，由于对象存活时间短，所以在新生代使用复制算法较为高效。对于老年代来说，可能大部分对象仍然需要存活下去，如果此时还是利用复制算法，效率会大大降低。标记-压缩算法的过程，首先还是对需要回收的内存进行标记，标记之后，将不用回收的内存对象压缩到内存的一端，然后直接清除边界外的内存。

## CMS收集器和G1收集器
CMS收集器是基于标记-清除算法实现的。他的运行过程大致分为：
- 初始标记
- 并发标记
- 重新标记
- 并发清除
初始标记和并发标记着两个过程仍然需要stop the world，初始标记仅仅是标记GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing 的过程，重新标记阶段是为了修正在并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。（老年代收集器）

缺点：
产生大量的内存碎片，并发阶段会降低系统的吞吐量

G1收集器
与CMS收集器相比，G1收集器的最大的特点是可预测停顿时间。
G1收集器可以不和其他收集器配合就能独立管理整个堆，但是还是保留了分代的概念，它能采用不同的方式去处理新创建的和已经存活一段时间的旧对象。

   
   